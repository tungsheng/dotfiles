#!/bin/bash
# Dotfiles installer - bash 3.2+ compatible
set -e
trap 'echo; exit 130' INT

# ============================================================================
# Configuration
# ============================================================================

DOTFILES_DIR="$(cd "$(dirname "$0")" && pwd)"

# Version: prefer git tag, fall back to VERSION file
get_version() {
    local ver
    if ver=$(git -C "$DOTFILES_DIR" describe --tags --always 2>/dev/null); then
        echo "${ver#v}"  # strip leading 'v'
    elif [[ -f "$DOTFILES_DIR/VERSION" ]]; then
        cat "$DOTFILES_DIR/VERSION" | tr -d '[:space:]'
    else
        echo "unknown"
    fi
}
VERSION="$(get_version)"
DRY_RUN=false
VERBOSE=false
USE_SHELL=""

# XDG Base Directories
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
STATE_DIR="$XDG_STATE_HOME/dotfiles"
STATE_FILE="$STATE_DIR/state"

# Dependencies table: command | brew | dnf | apt
# - Use "-" to indicate package is unavailable for that package manager
# - Use "-" for command to skip health check (install-only packages)
#
# Format: "command | brew-pkg | dnf-pkg | apt-pkg"
DEPS=(
    "stow     | stow      | stow      | stow"
    "nvim     | neovim    | neovim    | neovim"
    "fd       | fd        | fd-find   | fd-find"
    "rg       | ripgrep   | ripgrep   | ripgrep"
    "fzf      | fzf       | fzf       | fzf"
    "zoxide   | zoxide    | -         | zoxide"       # Not in dnf repos
    "tmux     | tmux      | tmux      | tmux"
    "uv       | uv        | -         | -"            # Python package manager
    "marksman | marksman  | -         | -"            # Markdown LSP (brew only)
    "-        |           | git       | git"          # Install-only (skip health check)
    "-        |           | curl      | curl"
    "-        |           | zsh       | zsh"
    "-        |           | unzip     | unzip"
)

CASKS=("font-jetbrains-mono-nerd-font" "font-hurmit-nerd-font")

MANAGED_FILES=(.zshrc .bashrc .bash_profile .config/nvim .config/tmux/tmux.conf .config/alacritty/alacritty.toml .config/gh .config/shell)

# Extras: path|url|type|name (evaluated after XDG vars set)
EXTRAS=(
    "$XDG_DATA_HOME/git/git-prompt.sh|https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh|curl|git-prompt"
    "$HOME/.config/alacritty/themes|https://github.com/alacritty/alacritty-theme|git|alacritty-themes"
    "$HOME/.config/tmux/plugins/tpm|https://github.com/tmux-plugins/tpm|git|tpm"
)

# Cleanup: path|name
CLEANUPS=(
    "$HOME/.config/alacritty/themes|Alacritty themes"
    "$XDG_DATA_HOME/git|git-prompt.sh"
    "$XDG_DATA_HOME/zinit|Zinit"
    "$XDG_DATA_HOME/nvim|Neovim data"
    "$HOME/.config/tmux/plugins|Tmux plugins"
)

# ============================================================================
# Output (colors, logging, spinner)
# ============================================================================

RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[0;33m'
BLUE='\033[0;34m' CYAN='\033[0;36m' DIM='\033[2m' BOLD='\033[1m' NC='\033[0m'

# Install summary tracking
INSTALLED_ITEMS=()
SKIPPED_ITEMS=()

track_installed() { INSTALLED_ITEMS+=("$1"); }
track_skipped()   { SKIPPED_ITEMS+=("$1 ${DIM}($2)${NC}"); }

# Spinner for long-running operations (bash 3.2 compatible)
spin() {
    local pid=$1 msg=$2
    local chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0 len=${#chars}
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r ${BLUE}%s${NC}  %s" "${chars:$i:1}" "$msg"
        i=$(( (i + 1) % len ))
        sleep 0.1
    done
    printf "\r"
}

# Run command with spinner
run_with_spin() {
    local msg="$1"
    shift
    if "$DRY_RUN"; then
        log_dim "[dry-run] $*"
        return 0
    fi
    "$@" >/dev/null 2>&1 &
    local pid=$!
    spin "$pid" "$msg"
    wait "$pid"
}

print_banner() {
    echo -e "${BOLD}"
    cat <<'EOF'

        ╺┳┓┏━┓╺┳╸┏━╸╻╻  ┏━╸┏━┓
         ┃┃┃ ┃ ┃ ┣╸ ┃┃  ┣╸ ┗━┓
        ╺┻┛┗━┛ ╹ ╹  ╹┗━╸┗━╸┗━┛
EOF
    echo -e "${NC}${DIM}        v${VERSION}${NC}"
    echo
}

# Logging: icon + message, consistent 3-char prefix
log_ok()   { echo -e " ${GREEN}✓${NC}  $1"; }
log_fail() { echo -e " ${RED}✗${NC}  $1" >&2; }
log_warn() { echo -e " ${YELLOW}!${NC}  $1"; }
log_info() { echo -e " ${BLUE}→${NC}  $1"; }
log_dim()  { echo -e "     ${DIM}$1${NC}"; }

log_step() {
    echo
    echo -e " ${BOLD}[$1/$2]${NC} ${BOLD}$3${NC}"
}

log_summary() {
    local ok="$1" fail="$2" warn="${3:-0}"
    echo
    echo -n " "
    [ "$ok" -gt 0 ] && echo -ne "${GREEN}$ok ok${NC}  "
    [ "$fail" -gt 0 ] && echo -ne "${RED}$fail failed${NC}  "
    [ "$warn" -gt 0 ] && echo -ne "${YELLOW}$warn warnings${NC}"
    echo
}

# ============================================================================
# Helpers
# ============================================================================

run() {
    if "$DRY_RUN"; then
        log_dim "[dry-run] $*"
    else
        "$VERBOSE" && log_dim "\$ $*"
        "$@"
    fi
}

has_cmd()  { command -v "$1" >/dev/null 2>&1; }
has_path() { [ -e "$1" ]; }

detect_os() {
    case "$OSTYPE" in darwin*) echo "macos"; return ;; esac
    has_cmd dnf && echo "fedora" && return
    has_cmd apt && echo "debian" && return
    echo "unknown"
}

get_packages() {
    local col="$1" pkg result=""
    for item in "${DEPS[@]}"; do
        pkg=$(echo "$item" | cut -d'|' -f"$col" | tr -d ' ')
        [ -n "$pkg" ] && [ "$pkg" != "-" ] && result="$result$pkg "
    done
    echo "${result% }"  # trim trailing space
}

print_usage() {
    print_banner
    echo -e " ${BOLD}Usage:${NC} ./dot <command> [options]"
    echo
    echo -e " ${BOLD}Commands${NC}"
    echo "   install      Install dotfiles and dependencies"
    echo "   uninstall    Remove symlinks and optionally clean up"
    echo "   health       Check installation status"
    echo "   status       Quick overview of installation state"
    echo
    echo -e " ${BOLD}Options${NC}"
    echo "   -n, --dry-run    Show what would be done"
    echo "   -v, --verbose    Show commands being run"
    echo "   -h, --help       Show this help"
    echo
    echo -e " ${BOLD}Examples${NC}"
    echo "   ./dot install        Install everything"
    echo "   ./dot install -n     Preview install"
    echo "   ./dot status         Quick status"
    echo "   ./dot health         Full health check"
}

# ============================================================================
# Commands
# ============================================================================

get_cmd_version() {
    local cmd="$1"
    case "$cmd" in
        nvim)    "$cmd" --version 2>/dev/null | head -1 | sed 's/NVIM v//' ;;
        tmux)    "$cmd" -V 2>/dev/null | cut -d' ' -f2 ;;
        zoxide)  "$cmd" --version 2>/dev/null | cut -d' ' -f2 ;;
        fzf)     "$cmd" --version 2>/dev/null | cut -d' ' -f1 ;;
        fd)      "$cmd" --version 2>/dev/null | cut -d' ' -f2 ;;
        rg)      "$cmd" --version 2>/dev/null | head -1 | cut -d' ' -f2 ;;
        stow)    "$cmd" --version 2>/dev/null | head -1 | awk '{print $NF}' ;;
        uv)      "$cmd" --version 2>/dev/null | cut -d' ' -f2 ;;
        *)       echo "" ;;
    esac
}

cmd_health() {
    print_banner
    echo -e " ${BOLD}Health Check${NC}"
    local ok=0 fail=0 warn=0
    local os
    os=$(detect_os)

    echo
    echo -e " ${DIM}Shell: $SHELL${NC}"
    echo -e " ${DIM}OS: $os${NC}"

    # --- Symlinks ---
    log_step 1 4 "Symlinks"
    for file in "${MANAGED_FILES[@]}"; do
        if [ -L "$HOME/$file" ]; then
            log_ok "$file"
            ok=$((ok + 1))
        elif [ -e "$HOME/$file" ]; then
            log_warn "$file ${DIM}(exists but not symlinked)${NC}"
            warn=$((warn + 1))
        else
            log_fail "$file"
            fail=$((fail + 1))
        fi
    done

    # --- Dependencies ---
    log_step 2 4 "Dependencies"
    for item in "${DEPS[@]}"; do
        local cmd brew_pkg dnf_pkg apt_pkg
        cmd=$(echo "$item" | cut -d'|' -f1 | tr -d ' ')
        brew_pkg=$(echo "$item" | cut -d'|' -f2 | tr -d ' ')
        dnf_pkg=$(echo "$item" | cut -d'|' -f3 | tr -d ' ')
        apt_pkg=$(echo "$item" | cut -d'|' -f4 | tr -d ' ')

        [ "$cmd" = "-" ] || [ -z "$cmd" ] && continue

        if has_cmd "$cmd"; then
            local ver
            ver=$(get_cmd_version "$cmd")
            if [ -n "$ver" ]; then
                log_ok "$cmd ${DIM}$ver${NC}"
            else
                log_ok "$cmd"
            fi
            ok=$((ok + 1))
        else
            # Show install hint based on OS
            local hint=""
            case "$os" in
                macos)  [ "$brew_pkg" != "-" ] && [ -n "$brew_pkg" ] && hint="brew install $brew_pkg" ;;
                fedora) [ "$dnf_pkg" != "-" ] && [ -n "$dnf_pkg" ] && hint="sudo dnf install $dnf_pkg" ;;
                debian) [ "$apt_pkg" != "-" ] && [ -n "$apt_pkg" ] && hint="sudo apt install $apt_pkg" ;;
            esac
            if [ -n "$hint" ]; then
                log_fail "$cmd ${DIM}(run: $hint)${NC}"
            else
                log_fail "$cmd ${DIM}(not available for $os)${NC}"
            fi
            fail=$((fail + 1))
        fi
    done

    # --- Fonts ---
    log_step 3 4 "Fonts"
    local font_dir="$HOME/Library/Fonts"
    for font in "JetBrainsMono" "Hurmit"; do
        if has_cmd fc-list; then
            # Linux or macOS with fontconfig
            if fc-list | grep -qi "${font}.*Nerd"; then
                log_ok "$font Nerd Font"
                ok=$((ok + 1))
            else
                log_warn "$font Nerd Font ${DIM}(not installed)${NC}"
                warn=$((warn + 1))
            fi
        elif [ -d "$font_dir" ]; then
            # macOS fallback: check font directory
            if ls "$font_dir" 2>/dev/null | grep -qi "$font"; then
                log_ok "$font Nerd Font"
                ok=$((ok + 1))
            else
                log_warn "$font Nerd Font ${DIM}(not installed)${NC}"
                warn=$((warn + 1))
            fi
        else
            log_dim "Cannot verify fonts"
            break
        fi
    done

    # --- Plugins ---
    log_step 4 4 "Plugins"
    local plugins=(
        "$XDG_DATA_HOME/zinit|zinit"
        "$XDG_DATA_HOME/nvim/lazy|lazy.nvim"
        "$HOME/.config/tmux/plugins/tpm|tpm"
    )
    for item in "${plugins[@]}"; do
        local p="${item%%|*}" name="${item##*|}"
        if has_path "$p"; then
            local count="" count_dir="$p"
            # tpm counts from plugins dir, not tpm subdir
            [ "$name" = "tpm" ] && count_dir="$HOME/.config/tmux/plugins"
            if [ -d "$count_dir" ]; then
                count=$(find "$count_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
            fi
            if [ -n "$count" ] && [ "$count" != "0" ]; then
                log_ok "$name ${DIM}($count plugins)${NC}"
            else
                log_ok "$name"
            fi
            ok=$((ok + 1))
        else
            log_warn "$name ${DIM}(not installed)${NC}"
            warn=$((warn + 1))
        fi
    done

    log_summary "$ok" "$fail" "$warn"
}

cmd_status() {
    local os
    os=$(detect_os)

    echo
    echo -e " ${BOLD}Dotfiles Status${NC}"
    echo -e " ${DIM}───────────────────────────────────────${NC}"

    # Count symlinks
    local symlinks_ok=0 symlinks_total=${#MANAGED_FILES[@]}
    for file in "${MANAGED_FILES[@]}"; do
        [ -L "$HOME/$file" ] && symlinks_ok=$((symlinks_ok + 1))
    done
    if [ "$symlinks_ok" -eq "$symlinks_total" ]; then
        echo -e " ${GREEN}Symlinks${NC}     $symlinks_ok/$symlinks_total active"
    else
        echo -e " ${YELLOW}Symlinks${NC}     $symlinks_ok/$symlinks_total active"
    fi

    # Shell info
    local shell_name="${SHELL##*/}"
    local shell_info="$shell_name"
    if [ "$shell_name" = "zsh" ] && [ -d "$XDG_DATA_HOME/zinit" ]; then
        shell_info="$shell_name ${DIM}(zinit loaded)${NC}"
    fi
    echo -e " ${CYAN}Shell${NC}        $shell_info"

    # Neovim plugins
    local lazy_dir="$XDG_DATA_HOME/nvim/lazy"
    if [ -d "$lazy_dir" ]; then
        local nvim_plugins
        nvim_plugins=$(find "$lazy_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
        echo -e " ${CYAN}Neovim${NC}       lazy.nvim ${DIM}($nvim_plugins plugins)${NC}"
    else
        echo -e " ${DIM}Neovim${NC}       not configured"
    fi

    # Tmux plugins
    local tpm_dir="$HOME/.config/tmux/plugins"
    if [ -d "$tpm_dir" ]; then
        local tmux_plugins
        tmux_plugins=$(find "$tpm_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
        echo -e " ${CYAN}Tmux${NC}         tpm ${DIM}($tmux_plugins plugins)${NC}"
    else
        echo -e " ${DIM}Tmux${NC}         not configured"
    fi

    # OS
    echo -e " ${CYAN}OS${NC}           $os"

    # Last state file update
    if [ -f "$STATE_FILE" ]; then
        local last_sync
        last_sync=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$STATE_FILE" 2>/dev/null || stat -c "%y" "$STATE_FILE" 2>/dev/null | cut -d'.' -f1)
        echo -e " ${CYAN}Last sync${NC}    $last_sync"
    fi

    echo
    echo -e " ${DIM}Run './dot health' for full check${NC}"
    echo
}

cmd_uninstall() {
    print_banner
    echo -e " ${BOLD}Uninstall${NC}"
    "$DRY_RUN" && echo -e " ${DIM}Dry run - no changes will be made${NC}"

    has_cmd stow || { log_fail "stow not found"; exit 1; }

    log_step 1 2 "Remove symlinks"
    cd "$DOTFILES_DIR"
    if "$DRY_RUN"; then
        log_dim "[dry-run] stow --target=\$HOME --delete ."
    else
        stow --target="$HOME" --delete .
    fi
    log_ok "Symlinks removed"

    if "$DRY_RUN"; then
        log_step 2 2 "Cleanup"
        log_dim "[dry-run] skipped"
        return
    fi

    log_step 2 2 "Cleanup"
    log_dim "Optional - press y to remove, Enter to skip"
    echo
    for item in "${CLEANUPS[@]}"; do
        local p="${item%%|*}" name="${item##*|}"
        if has_path "$p"; then
            printf "     Remove %s? [y/N] " "$name"
            read -r REPLY
            case "$REPLY" in
                [Yy]*) rm -rf "$p"; log_ok "Removed $name" ;;
                *)     log_dim "Kept $name" ;;
            esac
        fi
    done
    rm -rf "$XDG_STATE_HOME/nvim" "${XDG_CACHE_HOME:-$HOME/.cache}/nvim" 2>/dev/null || true

    echo
    log_ok "Uninstall complete"
    log_dim "System packages were not removed"
}

cmd_install() {
    print_banner
    local os
    os=$(detect_os)

    echo -e " ${BOLD}Install${NC}"
    echo -e " ${DIM}OS: $os${NC}"
    "$DRY_RUN" && echo -e " ${DIM}Dry run - no changes will be made${NC}"

    # Step 1: Backup
    log_step 1 5 "Backup"
    local backed_up=0
    if "$DRY_RUN"; then
        log_dim "[dry-run] skipped"
    else
        local backup_dir=""
        for file in "${MANAGED_FILES[@]}"; do
            if [ -e "$HOME/$file" ] && [ ! -L "$HOME/$file" ]; then
                if [ -z "$backup_dir" ]; then
                    backup_dir="$STATE_DIR/backups/$(date +%Y%m%d-%H%M%S)"
                    mkdir -p "$backup_dir"
                    log_dim "Location: $backup_dir"
                fi
                cp -r "$HOME/$file" "$backup_dir/"
                log_ok "$file"
                backed_up=$((backed_up + 1))
            fi
        done
        [ "$backed_up" -eq 0 ] && log_ok "Nothing to backup"
    fi

    # Step 2: Dependencies
    log_step 2 5 "Dependencies"
    install_deps "$os"

    # Step 3: Shell
    log_step 3 5 "Shell"
    choose_shell

    # Step 4: Extras
    log_step 4 5 "Extras"
    install_extras

    # Step 5: Symlinks
    log_step 5 5 "Symlinks"
    cd "$DOTFILES_DIR"
    if "$DRY_RUN"; then
        log_dim "[dry-run] stow --target=\$HOME --restow ."
        log_ok "Ready"
    else
        stow --target="$HOME" --restow .
        log_ok "Created"
    fi

    # Save state
    if ! "$DRY_RUN"; then
        mkdir -p "$STATE_DIR"
        echo "installed=$(date +%Y-%m-%d\ %H:%M:%S)" > "$STATE_FILE"
        echo "os=$os" >> "$STATE_FILE"
        echo "shell=$USE_SHELL" >> "$STATE_FILE"
    fi

    # Summary
    echo
    print_install_summary

    # Done
    echo
    echo -e " ${GREEN}${BOLD}Done!${NC}"
    echo
    echo -e " ${BOLD}Next steps${NC}"
    if [ "$USE_SHELL" = "bash" ]; then
        echo -e "   ${CYAN}1.${NC} Restart terminal"
        echo -e "   ${CYAN}2.${NC} Open ${BOLD}nvim${NC} to install plugins"
        echo -e "   ${CYAN}3.${NC} Open ${BOLD}tmux${NC}, press ${BOLD}Ctrl+Space I${NC}"
    else
        echo -e "   ${CYAN}1.${NC} Restart terminal"
        echo -e "   ${CYAN}2.${NC} Run ${BOLD}p10k configure${NC}"
        echo -e "   ${CYAN}3.${NC} Open ${BOLD}nvim${NC} to install plugins"
        echo -e "   ${CYAN}4.${NC} Open ${BOLD}tmux${NC}, press ${BOLD}Ctrl+Space I${NC}"
    fi
    echo
    log_dim "Verify: ./dot health"
    echo
}

print_install_summary() {
    if [ ${#INSTALLED_ITEMS[@]} -gt 0 ] || [ ${#SKIPPED_ITEMS[@]} -gt 0 ]; then
        echo -e " ${BOLD}Summary${NC}"

        if [ ${#INSTALLED_ITEMS[@]} -gt 0 ]; then
            if "$DRY_RUN"; then
                echo -ne " ${GREEN}Ready:${NC} "
            else
                echo -ne " ${GREEN}Installed:${NC} "
            fi
            local first=true
            for item in "${INSTALLED_ITEMS[@]}"; do
                "$first" || echo -n ", "
                echo -n "$item"
                first=false
            done
            echo
        fi

        if [ ${#SKIPPED_ITEMS[@]} -gt 0 ]; then
            echo -e " ${YELLOW}Skipped:${NC}"
            for item in "${SKIPPED_ITEMS[@]}"; do
                echo -e "     ${DIM}-${NC} $item"
            done
        fi
    fi
}

# ============================================================================
# Install Helpers
# ============================================================================

show_skipped_deps() {
    local os="$1"
    local col
    case "$os" in
        macos)  col=2 ;;
        fedora) col=3 ;;
        debian) col=4 ;;
        *)      return ;;
    esac

    for item in "${DEPS[@]}"; do
        local cmd pkg
        cmd=$(echo "$item" | cut -d'|' -f1 | tr -d ' ')
        pkg=$(echo "$item" | cut -d'|' -f"$col" | tr -d ' ')

        # Skip if package is available or if it's an install-only dep
        [ "$cmd" = "-" ] && continue
        [ -n "$pkg" ] && [ "$pkg" != "-" ] && continue

        track_skipped "$cmd" "not available for $os"
    done
    return 0
}

install_deps() {
    local os="$1"

    # Show packages that will be skipped on this OS
    show_skipped_deps "$os"

    case "$os" in
        macos)
            if ! has_cmd brew; then
                log_info "Installing Homebrew..."
                if "$DRY_RUN"; then
                    log_dim "[dry-run] /bin/bash -c \"\$(curl ... install.sh)\""
                else
                    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
                    # Apple Silicon or Intel Mac
                    if [ -f /opt/homebrew/bin/brew ]; then
                        eval "$(/opt/homebrew/bin/brew shellenv)"
                    elif [ -f /usr/local/bin/brew ]; then
                        eval "$(/usr/local/bin/brew shellenv)"
                    fi
                fi
            fi
            log_ok "Homebrew"

            local pkgs
            pkgs=$(get_packages 2)
            if [ -n "$pkgs" ]; then
                if "$DRY_RUN"; then
                    log_dim "[dry-run] brew install $pkgs"
                else
                    run_with_spin "Installing packages..." brew install --quiet $pkgs
                fi
                log_ok "Packages"
                track_installed "packages"
            fi

            if "$DRY_RUN"; then
                log_dim "[dry-run] brew install --cask ${CASKS[*]}"
            else
                run_with_spin "Installing fonts..." brew install --quiet --cask "${CASKS[@]}"
            fi
            log_ok "Fonts"
            track_installed "fonts"
            ;;

        fedora)
            log_info "Adding EPEL..."
            if "$DRY_RUN"; then
                log_dim "[dry-run] sudo dnf install -y epel-release"
            else
                sudo dnf install -y epel-release 2>/dev/null || true
            fi
            log_ok "EPEL"

            local pkgs
            pkgs=$(get_packages 3)
            if [ -n "$pkgs" ]; then
                if "$DRY_RUN"; then
                    log_dim "[dry-run] sudo dnf install -y $pkgs"
                else
                    run_with_spin "Installing packages..." sudo dnf install -y $pkgs
                fi
                log_ok "Packages"
                track_installed "packages"
            fi

            if ! has_cmd zoxide; then
                log_info "Installing zoxide (not in dnf)..."
                if "$DRY_RUN"; then
                    log_dim "[dry-run] curl ... zoxide install.sh | bash"
                else
                    curl -sS https://raw.githubusercontent.com/ajeetdsouza/zoxide/main/install.sh | bash >/dev/null 2>&1
                fi
                log_ok "zoxide"
                track_installed "zoxide"
            fi
            ;;

        debian)
            log_info "Updating apt..."
            if "$DRY_RUN"; then
                log_dim "[dry-run] sudo apt update"
            else
                run_with_spin "Updating package lists..." sudo apt update
            fi
            log_ok "Updated"

            local pkgs
            pkgs=$(get_packages 4)
            if [ -n "$pkgs" ]; then
                if "$DRY_RUN"; then
                    log_dim "[dry-run] sudo apt install -y $pkgs"
                else
                    run_with_spin "Installing packages..." sudo apt install -y $pkgs
                fi
                log_ok "Packages"
                track_installed "packages"
            fi
            ;;

        *)
            log_warn "Unknown OS"
            log_dim "Install manually: stow neovim fd ripgrep fzf zoxide tmux git curl zsh"
            has_cmd stow || { log_fail "stow required"; exit 1; }
            ;;
    esac
}

install_extras() {
    for item in "${EXTRAS[@]}"; do
        local p url type name
        p="${item%%|*}"; item="${item#*|}"
        url="${item%%|*}"; item="${item#*|}"
        type="${item%%|*}"
        name="${item##*|}"

        if has_path "$p"; then
            log_ok "$name"
        else
            case "$type" in
                curl) log_info "Downloading $name"
                      run mkdir -p "$(dirname "$p")"
                      run curl -sS -o "$p" "$url" ;;
                git)  log_info "Cloning $name"
                      run mkdir -p "$(dirname "$p")"
                      run git clone --depth 1 -q "$url" "$p" ;;
            esac
            log_ok "$name"
        fi
    done
}

choose_shell() {
    if has_cmd zsh; then
        USE_SHELL="zsh"
        set_shell
        return
    fi

    log_warn "zsh not found"
    echo
    printf "     Use bash instead? [Y/n] "
    read -r REPLY
    case "$REPLY" in
        [Nn]*)
            log_fail "Aborted"
            log_dim "Install zsh first, then re-run ./dot install"
            exit 1
            ;;
        *)
            USE_SHELL="bash"
            set_shell
            ;;
    esac
}

set_shell() {
    local shell_path current_shell

    if [ "$USE_SHELL" = "bash" ]; then
        shell_path=$(command -v bash)
        current_shell="bash"
    else
        shell_path=$(command -v zsh)
        current_shell="zsh"
    fi

    # Already default?
    case "$SHELL" in
        */"$current_shell")
            log_ok "$USE_SHELL (already default)"
            return
            ;;
    esac

    if "$DRY_RUN"; then
        log_dim "[dry-run] chsh -s $shell_path"
        log_ok "$USE_SHELL"
        return
    fi

    # Add to /etc/shells if needed
    if ! grep -q "^${shell_path}$" /etc/shells 2>/dev/null; then
        log_info "Adding to /etc/shells"
        echo "$shell_path" | sudo tee -a /etc/shells >/dev/null
    fi

    # Change shell
    log_info "Setting default shell"
    if chsh -s "$shell_path"; then
        log_ok "$USE_SHELL"
        log_dim "Restart terminal to use"
    else
        log_warn "Could not set shell"
        log_dim "Run: chsh -s $shell_path"
    fi
}

# ============================================================================
# Main
# ============================================================================

main() {
    local cmd=""

    while [ $# -gt 0 ]; do
        case "$1" in
            install|uninstall|health|status) cmd="$1"; shift ;;
            -n|--dry-run) DRY_RUN=true; shift ;;
            -v|--verbose) VERBOSE=true; shift ;;
            -h|--help) print_usage; exit 0 ;;
            *) log_fail "Unknown: $1"; echo; print_usage; exit 1 ;;
        esac
    done

    if [ -z "$cmd" ]; then
        print_usage
        exit 0
    fi

    case "$cmd" in
        install)   cmd_install ;;
        uninstall) cmd_uninstall ;;
        health)    cmd_health ;;
        status)    cmd_status ;;
    esac
}

main "$@"
